<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
  <title>Многопоточная сортировка слиянием</title>
  <link rel="stylesheet" href="stylesMain.css">
  <link rel="stylesheet" href="stylesButton.css">
  <link rel="stylesheet" href="stylesText.css">
</head>
<body>

  <header>
    <h1>Многопоточная сортировка слиянием</h1>
  </header>

  <!-- Первый раздел -->
  <section class="content-section">
    <div class="content-wrapper">
        <h1>Теория</h1>
        <p>Сортировка слиянием (MergeSort) — это эффективный алгоритм сортировки, основанный на принципе "разделяй и властвуй".Сортировка слиянием (MergeSort) была разработана Джоном фон Нейманом в 1945 году. 
            Она появилась в ходе исследований эффективных методов обработки данных на ранних компьютерах. 
            Алгоритм основывается на принципе «разделяй и властвуй», рекурсивно разделяя массив на подмассивы до тех пор, пока каждый не станет размером в один элемент. 
            Затем происходит слияние этих подмассивов в отсортированном порядке, формируя более крупные отсортированные массивы. В конечном итоге это приводит к полностью отсортированному массиву путем последовательного слияния отсортированных подмассивов.
          </p>
        <ol>
          <li><strong>Исходный массив:</strong> [13, 3, 8, 1, 15, 2, 3, 7, 4]</li>
          <li><strong>Первое разделение:</strong> [13, 3, 8, 1] и [15, 2, 3, 7, 4]</li>
          <li><strong>Разделение левой половины:</strong> [13, 3] и [8, 1]</li>
          <li><strong>Дальнейшее разделение до единичных элементов:</strong> [13], [3], [8], [1]</li>
          <li><strong>Слияние и сортировка левой половины:</strong> [3, 13] и [1, 8]</li>
          <li><strong>Слияние отсортированных подмассивов:</strong> [1, 3, 8, 13]</li>
          <li><strong>Разделение правой половины:</strong> [15, 2] и [3, 7, 4]</li>
          <li><strong>Дальнейшее разделение правой половины:</strong> [15], [2], [3], [7], [4]</li>
          <li><strong>Слияние и сортировка правой половины:</strong> [2, 15] и [3, 4, 7]</li>
          <li><strong>Объединение правой половины:</strong> [2, 3, 4, 7, 15]</li>
          <li><strong>Окончательное слияние:</strong> [1, 2, 3, 3, 4, 7, 8, 13, 15]</li>
        </ol>
      </div>
      <div class="image-block">
        <!-- Вставь сюда первое изображение -->
        <img src="https://neerc.ifmo.ru/wiki/images/thumb/3/3a/Merge_sort_itearative.png/300px-Merge_sort_itearative.png" alt="Example">
      </div>
    </div>
  </section>

  <!-- Второй раздел -->
  <section class="content-section reverse">
    <div class="content-wrapper">
      <div class="image-block">
        <!-- Вставь сюда второе изображение -->
        <img src="https://neerc.ifmo.ru/wiki/images/6/62/MergeMT.png" alt="SecondExample">
      </div>
      <div class="text-block">
        <!-- Вставь сюда второй блок текста с теорией -->
        <h1>Как задействовать многопоточность?</h1>
        <p>Многопоточная сортировка слиянием работает путем рекурсивного разделения исходного массива на две части, где каждая часть сортируется в отдельном потоке параллельно с другой. Например, для массива [13, 3, 8, 1, 15, 2, 3, 7, 4] он делится на [13, 3, 8, 1] и [15, 2, 3, 7, 4], которые обрабатываются в разных потоках. В каждом потоке подмассивы снова делятся и сортируются в новых потоках, позволяя одновременную обработку нескольких частей массива. После сортировки подмассивов в потоках происходит их слияние в отсортированные массивы, что также может выполняться параллельно. В конечном итоге отсортированные части объединяются в один общий отсортированный массив. Такой подход эффективно использует многопоточность для ускорения сортировки за счет параллельной обработки и объединения данных.</p>
      </div>
    </div>
  </section>

  <!-- Третий раздел -->
  <section class="content-section">
    <div class="content-wrapper">
        <div class="text-block">
            <h1>Алгоритм MergeSort</h1>
             <p> Рассмотрим рисунки. На рисунке 2 функция <code>mergeSortRecursive</code> отвечает за рекурсивное деление массива. Если подотрезок массива содержит более одного элемента, он вычисляет середину и рекурсивно сортирует левую и правую половины. После сортировки двух половин вызывается функция <code>merge</code>, которая объединяет их в один отсортированный подотрезок.<br><br>
                На рисунке 1 функция <code>merge</code> использует два указателя <code>it1</code> и <code>it2</code> для отслеживания текущих позиций в левых и правых подмассивах. Она сравнивает элементы из левой и правой половин и добавляет меньший элемент в результирующий массив. Если один из подмассивов исчерпан, оставшиеся элементы другого подмассива добавляются в результат. После объединения результирующий подотрезок копируется обратно в исходный массив. Рекурсивный подход обеспечивает логарифмическую глубину вызовов, что делает алгоритм эффективным по времени.<br><br>
                На рисунке 2 итеративный алгоритм <code>mergeSortIterative</code> использует циклы вместо рекурсии, что снижает использование памяти за счет отсутствия накладных расходов на вызовы функций. В итеративном методе массив сортируется с использованием размеров подотрезков, увеличивающихся в геометрической прогрессии. На каждом этапе объединяются пары подотрезков фиксированного размера с помощью функции <code>merge</code>. Этот подход также обеспечивает временную сложность O(n log n) и снижает потребление памяти. Итеративный метод может быть предпочтительным в системах с ограниченной памятью или где рекурсия может привести к переполнению стека.<br><br>
                Оба подхода стабильны, что означает сохранение относительного порядка равных элементов. MergeSort хорошо подходит для сортировки больших массивов благодаря своей предсказуемой производительности. Однако он требует дополнительной памяти для временных массивов при <strong>слиянии</strong>. Внешняя сортировка также часто реализуется с использованием MergeSort из-за его способности эффективно работать с большими объемами данных.<br><br>
                Самое важное для практики данного сайта - алгоритм легко параллелится, так как подзадачи сортировки отдельных подмассивов могут выполняться одновременно. Реализация MergeSort требует аккуратного управления индексами и памятью для предотвращения ошибок. Несмотря на дополнительную память, MergeSort остается популярным выбором благодаря своей надежности и эффективности. Важно выбирать подходящий вариант (рекурсивный или итеративный) в зависимости от конкретных требований и ограничений системы. В целом, MergeSort является фундаментальным алгоритмом, изучаемым в информатике и используемым на практике в различных приложениях сортировки.</p>
    </div>
          <div class="image-block">
            <!-- Первое изображение с подписью -->
            <figure>
              <img src="https://i.pinimg.com/736x/04/6d/6a/046d6a2de9637a43701eda8907d236fa.jpg" alt="Algorithm1">
              <figcaption>Рисунок 1: Псевдокод  алгоритма MergeSort</figcaption>
            </figure>
            
            <!-- Второе изображение с подписью -->
            <figure>
              <img src="https://i.pinimg.com/736x/e3/e6/6d/e3e66d310d2b9f5b956447cc7733e1fd.jpg" alt="Algorithm2">
              <figcaption>Рисунок 2: Алгоритм объединения в MergeSort</figcaption>
            </figure>
          </div>
    </div>
  </section>

    <!-- 4 раздел -->
    <section class="content-section reverse">
        <div class="content-wrapper">
            <div class="image-block">
                <!-- 5 изображение с подписью -->
                  <img src="https://i.pinimg.com/736x/66/3d/28/663d28bcb7cb2d318240cdb1ebfd8dd7.jpg" alt="Async">
              </div>
              <div class="text-block">
                <h1>Многопоточность Алгоритма MergeSort в JavaScript</h1>
                <p> JavaScript-код на картинке демонстрирует реализацию алгоритма MergeSort с использованием асинхронных функций для имитации параллельного выполнения. Функция <code>mergeSort</code> объявлена как асинхронная и использует <code><u>Promise.all()</u></code> для одновременной сортировки левой и правой половин массива. Оператор <code><strong>await</strong></code> перед <code><u>Promise.all()</u></code> гарантирует, что слияние происходит только после завершения сортировки обеих половин. Такой подход имитирует многопоточность, позволяя обработчику событий JavaScript выполнять другие задачи во время ожидания. Функция <code>merge</code> объединяет отсортированные половины в единый массив, следуя стандартной процедуре MergeSort. В контексте MergeSort эта параллелизация может улучшить производительность в системах, поддерживающих асинхронные операции. Использование асинхронных функций не создает истинной многопоточности, но оптимизирует сортировку в средах, способных эффективно управлять асинхронными задачами. Эта реализация показывает, как стандартные алгоритмы могут адаптироваться для использования асинхронных возможностей современных языков программирования. Она демонстрирует гибкость MergeSort в рекурсивных и итеративных формах, а также его пригодность для параллельной обработки. В целом, код предоставляет практический пример интеграции асинхронного программирования с классическими алгоритмами сортировки.</p>
              </div>
        </div>
      </section>

  <!-- 5 раздел -->
  <section class="interactive-section">
    <h1>Практика</h1>
    <div class="interactive-wrapper">
      <div class="cells-container">
        <!-- Создаем 10 ячеек для ввода цифр -->
        <input type="text" maxlength="1" class="cell">
        <input type="text" maxlength="1" class="cell">
        <input type="text" maxlength="1" class="cell">
        <input type="text" maxlength="1" class="cell">
        <input type="text" maxlength="1" class="cell">
        <input type="text" maxlength="1" class="cell">
        <input type="text" maxlength="1" class="cell">
        <input type="text" maxlength="1" class="cell">
        <input type="text" maxlength="1" class="cell">
        <input type="text" maxlength="1" class="cell">
      </div>
      <!-- Кнопки -->
      <div class="buttons-container">
        <button id="generate-button">Сгенерировать</button>
        <button id="run-button">Запустить</button>
        <button id="clear-button">Очистить</button> <!-- Новая кнопка -->
     </div>
    </div>
  </section>

  <script src="script.js"></script>
</body>
</html>
